- 프레임워크
  - 큰 뼈대를 만들어놓은 공장으로, 규칙에 맞게 코드 작성하면 결과물을 얻을 수 있는 도구.
- Next
  - 풀스택 웹 애플리케이션 프레임워크
  - 기존에는 클라이언트의 리액트와 서버의 express로 구성했는데, 이러한 과정이 넥스트에는 기본적으로 탑재되어 있어서 리액트와 서버를 통합하는 불편한 과정을 겪지 않아도 됨.
  - 넥스트가 매력적인 이유는 SSR을 기본적으로 제공한다는 점.
- CSR vs SSR
  - 핵심은 JS를 클라이언트에서 작동시키는지, 서버에서 작동시키는지.
  - 리액트와 같은 JS 라이브러리는 JS 기반으로 동작하기 때문에 JS를 다운받고 브라우저에서 실행시켜야 UI를 그릴 수 있음.
    - JS가 동작하지 않는 환경에서는 화면을 표시할 수 없기 때문에 검색엔진과 같은 로봇들이 검색할 수 없다는 치명적인 단점이 있음.
    - JS를 다운로드하고 실행하기 전까지는 화면이 표시되지 않는다는 단점.
  - SSR에서는 서버 쪽에서 JS가 실행됨.
    - JS가 실행되지 않는 환경에서도 잘 동작하고 검색엔진 친화적이며, 다운로드 받는 즉시 실행되기 때문에 사용자 입장에서도 눈 깜짝할 사이에 화면 보임.
- npx
  - node로 만들어진 프로그램을 설치 없이 바로 실행할 수 있는 컵라면처럼 간편한 프로그램
- @latest
  - 최신 버전으로 실행하겠다는 옵션.
- next 13버전부터
  - 앱 라우터가 도입됨. 이전엔 페이지 라우터 사용됨.
  - 앱 라우터는 개발 방법을 바꿔놓음.
- npm run start는 CRA에서, NEXT에서는 npm run dev 로 실행.
- 네트워크 탭 하단에 서버에서 받아오는 파일들의 용량 있음.
  - 개발 모드에서는 7.8 MB resources. 용량이 큼
  - 개발 모드에서는 개발자도구에 여러가지 정보가 나옴.
    - 이 정보들은 비효율적이고 때로는 보안상의 문제가 될 수도 있음.
    - 그래서 용량을 줄이고 불필요한 파일을 제거하여 실 서버에 맞게 최적화하는 과정이 필요함
  - build 명령어는 실 서버를 위한 배포판믈 만드는 명령어
    - .next폴더는 개발하든 빌드를 하든 사용자에게 서비스되는 내용이 저장되는 곳임
    - build 하면 배포판이 .next 폴더에 만들어짐
  - start 명령어는 배포판을 서비스 하는 명령어
    - .next에 있는 내용이 서비스되기 시작함.
  - 빌드 후에는 350 kB resources 로 용량이 줄어들었음.
  - 실서버 용으로 만드니까 훨씬 슬림해짐!
- 라우팅
  - https:// domain / path
  - path의 요소들을 segment라고 부름
  - 라우팅은 경로에 따라 어떤 콘텐츠들을 어떤 방식으로 보여줄 것인지에 관한 것
- next.js가 라우팅 처리하는 과정
  - /create로 접속하면 next는 app 내에서 create 폴더를 찾고, 그 아래에서 page.js를 찾음. 그리고 layout을 찾고, 없으면 부모의 layout을 찾음.
- 개발자 도구의 run command에서 disable javascript 할 수 있음. enable도 가능
  - 리액트는 JS기술이기 때문에 JS를 끄면 동작하지 않음.
  - 하지만 넥스트는 잘 동작함.
    - 넥스트가 서버에서 미리 실행해서 응답 결과를 .next 폴더에 저장해놓았다가 사용자가 요청하면 이를 응답하기 때문임.
- 네트워크 탭에서 fast 3G 등을 통해 성능을 낮춰볼 수 있음.
- 페이지에서 일부만 콘텐츠가 변경됨에도 전체 페이지를 모두 다운받음. 그리고 이미 방문한 적이 있는 페이지를 다시 방문해도 또 다운받음.
  - 이를 해결하기 위해서는 a 태그를 Link로 바꿔주면 됨.
  - 이렇게 하면 사용자 입장에서는 빠르게 결과 볼 수 있고, 제공자는 돈을 절약할 수 있음.
- Single Page Application
  - 이렇게 여러 페이지임에도 한 페이지에서 작동되는 앱인 것처럼 보이는걸 SPA라고 함.
- 서버컴포넌트
  - 리액트 18버전부터 추가된 개념.
  - 넥스트는 기본 컴포넌트를 서버컴포넌트로 간주.
  - 클라이언트 컴포넌트에서는 useState같은 훅, onClick 등의 api를 사용 가능
  - 정보를 표현하는데 사용사와 상호작용하지 않는 컴포넌트는 서버컴포넌트로.
  - 사용자와 상호작용하는 컴포넌트는 클라 컴포넌트. 버튼만 클라 컴포넌트로 만드는 것이 더 유리함.
  - 서버컴포넌트는 한번 렌더링해서 정적인 정보를 클라이언트로 보내주면 되기 때문에, 훅을 사용할 필요가 없는 것임.
  - 서버컴포넌트가 주는 장점이 기본적으로 있어서, 가능하다면 서버컴포넌트를 유지하는 것이 좋음.
- use client 사용해서 data fetch 할 경우
  - 서버가 멀리 있다면, 로딩이 오래 걸리고 비효율 발생
  - JS를 사용하지 않는 환경에서는 fetch되지 않음.
  - id 나 토큰 등이 클라이언트에 있다면 보안상 문제가 될 수도 있음.
  - 이를 해결하기 위해서는
    - 서버 컴포넌트로 바꿔줘야 함.
    - 동적인 것들을 서버에서 완료한 후 클라이언트로 정적인 결과만 보내는 것임.
    - 용량이 작고, 비용도 적음.
- json-server 실행
  - npx json-server --port 9999 --watch db.json
  - watch 는 db가 수정된 경우 재실행 하는 옵션
- 원래 form에서 onSubmit 하면 페이지가 새로고침 되는데, e.preventDefault() 하면 새로고침 안됨.
- 넥스트는 동일한 요청을 최적화하기 위해 cache 함.
  - 기본적으로 한번 저장된 것을 그대로 들고옴.
  - miss는 캐시를 사용하지 않았다. hit는 캐시를 사용했다는 의미.
  - revalidating 관련 독스 내용 살펴보기
  - 캐시를 끄고 진행할 수도 있음. 본 강의에서는 끄고 진행할 것. 그런데 언젠가는 극복해야 하는 숙제이니 미리 공부할 것.
  - .next를 지웠다가 다시 실행하면 새롭게 생성하면서 최신화됨.
- uesEffect의 사이드이펙트란 쉽게 말해서 외부의 값이나 상태를 변경시키는 것을 의미.
- api 수정 시에는 put이나 patch!
  - put은 모든 것을 업데이트. 빈 값을 넣으면 빈 값으로 바뀜.
  - patch는 일부만 업데이트. 선택한 것만 업데이트 함.
- 환경변수
  - .env.local
  - .env
